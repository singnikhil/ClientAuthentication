This code is target towards user who are trying to achieve Client Authentication and are looking to leverage CloudHSM to store private key. I will be using CloudHSM JCE library.


This document is covered into two parts:
i. Prerequisites
ii. Actual code

                                                      Prerequisites
						      
                                                      
There are two prerequisites for this setup:
1. Creating Client Certificate
2. Configuring Web Server to do Mutual Authentication. 

Creating Client Certificate:

Since you will be doing mutual authentication, you need a client certificate. 
For mutual authentication, you generally have your client certificate signed by a CA. This CA is added to the trust Store of Web Server. 
If your client certificate is signed by some this party, then you need to generate the CSR, and send the CSR to them for signing.
For creating the CSR, you will need to generate the RSA Keypair and then sign the CSR from public key of that certificate.

For this prequisite, I will be creating my own root CA and signing CSR from it.
To generate the CSR, you can use Openssl and follow the following steps:

1. export env variable n3fips_password:

    export n3fips_password=<CU user name>:<password>

Here your username and password will be HSM CU Username and password.

2. Use OpenSSL to generate a RSA Keypair in CloudHSM. 

openssl genrsa -engine cloudhsm -out clientAuth_reference.key 2048

In this command, I'm telling openssl to use engine cloudhsm to generate a 2048 bit RSA key. Please note that the key file generated by this command is a reference key. This is not an actual key, instead it has reference to key handle for RSA key that is generated by openssl and stored inside HSM. Your output for this command should be something like this:
	SDK Version: 2.03
engine "cloudhsm" set.
Generating RSA private key, 2048-bit long modulus
e is 65537 (0x10001)
Please note that in case openssl is not able to generate RSA key on HSM, it will generate still generate a RSA key, however that will be using the openssl software, not cloudHSM engine. To make sure that the file is a reference file, you can look at the output of the file. It will be a padded file, at the end and you can verify that padding. 

3. Generate a CSR:

openssl req -engine cloudhsm -new -key clientAuth_reference.key -out client.csr
Using this command, you will generate a CSR. clientAuth_reference.key is the same reference key that you generated using genrsa command in step 2.

4. After generating the CSR, you need to get it signed by a CA. As mentioned before I'm creating my own CA and signing the certificate with that CA. If you're getting your CSR signed by third party CA, you can skip this step. Here are steps for that:

   a. Generate a CA Keypair.

openssl genrsa -aes256 -out clientCA_reference.key 4096

This command will generate a 4096 bit RSA Keypair. The output file clientCA_reference.key is an actual RSA Key File, and is AES encrypted in CBC mode. AES Key is generated using a key derivation function from the password entered.

   b. Generate a CA Certificate

openssl req -new -x509 -days 7300 -key clientCA_reference.key -out clientCA.crt

This command will generate a CA Certificate having name clientCA.crt, and it's validity is 20 years(General Validity of root CA). Generally, Root CA certificates sign an intermediate certificate, and those intermediate certificates are used to sign other CSRs. However, I'm skipping that step and will sign my CSR with this root CA. At this point we've a certificate that we can use to sign the CSR. 

   c. Sign the CSR.
openssl x509 -req -days 547 -in client.csr -CA clientCA.crt -CAkey clientCA_reference.key -CAcreateserial -out clientAuth.crt

I've signed the CSR with self signed CA that I created in previous step. 
Now we've completed the perquisite for Creating Client Certificate. 

Configuring Web Server to do Mutual Authentication:
                                        
Generally Web Server setup will be done by the it's owner. In this setup, they enable mutual authentication, and will configure the client CA Certificate file for client certificate verification. If they've more than one certificate in their certificate chain, they can specify how many intermediate certificates to verify too. 
I will walk you through what configuration is to be done. 
I assume that you've configured a SSL Server.
Yo enable client authentication, goto your SSL.conf file and uncomment these lines:
SSLCACertificateFile /etc/pki/tls/certs/ca-bundle.crt
SSLVerifyClient require 
SSLVerifyDepth 10
SSLCACertificateFile is used to set CA certificate verification path where to find CA certificates for client authentication. ca-bundle.crt is the default CA certificate file. By default, it has list of all the well known root CA certificates in it. Since we're using our own self signed root CA, we'll need to put that CA certificate file here. If you want to use this file, you can paste your PEM encoded certificate in this file. Otherwise you can create a new file and put it's path there.
I'm creating a new file, and modifying it's path, as I only want to trust my specific CA. 
SSLVerifyClient This property is used to force clients to authenticate using certificates.
SSLVerifyDepth Depth is a number which specifies how deeply to verify the certificate issuer chain before deciding the certificate is not valid.

If you do not want to do mutual authentication for whole website, instead force clients to authenticate using certificates for a particular URL, you can use Location tag to achieve so. This is how you I've setup Client Certificate verification. This configuration goes into ssl.conf file inside VirtualHost directive.
SSLVerifyClient none 
SSLCACertificateFile /etc/pki/tls/certs/clientAuth.crt 
<Location "/mutualAuthExample"> 
    SSLVerifyClient require 
    SSLVerifyDepth 1 
</Location> 
Alias /mutualAuthExample /var/www/html/mutualAuth
This configuration will allow all the request coming for url <yourdomain>/mutualAuthExample/ to get files that are at path /var/www/html/mutualAuth after doing client verification. Client verification is not required for rest of domain. 
Restart your apache server after saving this configuration.  After this configuration, if you visit https://<yourdomain> you will be able to view the page, however, if you goto https://<yourdomain>/mutualAuthExample/ you should get ERR_BAD_SSL_CLIENT_AUTH_CERT error message, as your browser has not provided any client certificate for validation.

If you have not faced any issues in restarting server, and are receiving this error message, you have successfully configured web server. 
This covers up prerequisites section. Now, we'll move on to actual code. 



                                                            Understanding the Code
                                                            
At the time of publishing this code, CloudHSM does not support keystore functionality for JCE. As a workaround for that, user will be providing key alias for private key, and the path of certificate file of the client. 

Here are the list of Packages and classes along with methods:

1. com.amazonaws.cloudhsm.examples.mutualauth.main.MutualAuthRunner

    This is the main class. 

2. com.amazonaws.cloudhsm.examples.mutualauth.keystore.KeyStoreExample

    public CaviumRSAPrivateKey getPrivateKey(String alias) 
This method allows you to get the RSAPrivateKey from readonly keystore to get the key based on Alias provided. 
    public X509Certificate[] getCertificate(String certFile) 
This method will return you the X509Certificate object from the certfile that you provided. 
    public void validateKeyAndCert(CaviumRSAPrivateKey rsaPrivateKey, X509Certificate[] chain)
This method will allow you to valdiate weather Private key and cert are public private key pair or not.
3. com.amazonaws.cloudhsm.examples.mutualauth.keystore.ClientCertKeyManager extends X509ExtendedKeyManager

      This is a custom implementation of X509ExtendedKeyManager. I'm extending this abstract class to overwrite getCertificateChain() and getPrivateKey() method, so that I can create it's object and pass it onto SSLContext.init() method in SSLConnection class.

      I've created a constructor, to pass these privatekey and certchain.

ClientCertKeyManager(PrivateKey privKey, X509Certificate[] chain) 
4. com.amazonaws.cloudhsm.examples.mutualauth.operations.SSLConnection

      public void initalizeMutualAuth(CaviumRSAPrivateKey privKey, X509Certificate[] chain) 
This method will allow you to initialize the client authentication
      public void connectToUrl(String mutualAuthUrl) 
This method connects to the endpoint URL that you provide using --url argument when running the program.


These are main classes and rest other are certain dependencies that I put in place to make this code easier to manage.

Here's the CLI Reference:


    --cert-file <arg>           This option allows you to set an alias for
                                your KMS Key.
    --hsm-user-name <arg>       HSM CU User Username. If you're not
                                providing credentials using CLI, pass it
                                using env variables or system properties.
                                If just username is passed and not
                                password via options, password is to be
                                entered via prompt.
    --hsm-user-password <arg>   HSM CU User Username. If you're not
                                providing credentials using CLI, pass it
                                using env variables or system properties.
                                If just username is passed and not
                                password via options, password is to be
                                entered via prompt.
    --key-alias <arg>           This option allows you to set an alias for
                                your KMS Key.
    --url <arg>                 This option allows you to set an alias for
                                your KMS Key.
    --verify                    This option is used to verify if the key
                                and certificate are a match.
Sample command:

java -Djava.library.path=/opt/cloudhsm/lib/ -jar clientAuth.jar --cert-file /home/ec2-user/clientCertChain.crt --hsm-user-name cryptoUser --key-alias clientAuthRSAPrivKey --url https://clientauth.hsm.obscure.ninja/mutualAuthExample/ --hsm-user-password passw0rd@123 

